 sys/dev/mfi/mfireg.h          |   12 ++
 usr.sbin/mfiutil/Makefile     |    5 +-
 usr.sbin/mfiutil/mfi_bbu.c    |  249 +++++++++++++++++++++++++++++++++++++++++
 usr.sbin/mfiutil/mfi_cmd.c    |    4 +-
 usr.sbin/mfiutil/mfi_config.c |   26 ++---
 usr.sbin/mfiutil/mfi_drive.c  |   37 ++++--
 usr.sbin/mfiutil/mfi_evt.c    |    7 +-
 usr.sbin/mfiutil/mfi_flash.c  |    2 +-
 usr.sbin/mfiutil/mfi_patrol.c |   15 +--
 usr.sbin/mfiutil/mfi_show.c   |   80 ++++++++++---
 usr.sbin/mfiutil/mfi_volume.c |   10 +-
 usr.sbin/mfiutil/mfiutil.8    |   49 ++++++++
 usr.sbin/mfiutil/mfiutil.c    |    9 +-
 usr.sbin/mfiutil/mfiutil.h    |    9 +-
 14 files changed, 452 insertions(+), 62 deletions(-)

diff --git a/sys/dev/mfi/mfireg.h b/sys/dev/mfi/mfireg.h
index f005c37..92125c7 100644
--- a/sys/dev/mfi/mfireg.h
+++ b/sys/dev/mfi/mfireg.h
@@ -188,6 +188,9 @@ typedef enum {
 	MFI_DCMD_BBU_GET_STATUS =	0x05010000,
 	MFI_DCMD_BBU_GET_CAPACITY_INFO =0x05020000,
 	MFI_DCMD_BBU_GET_DESIGN_INFO =	0x05030000,
+	MFI_DCMD_BBU_START_LEARN =	0x05040000,
+	MFI_DCMD_BBU_GET_PROP =		0x05050100,
+	MFI_DCMD_BBU_SET_PROP =		0x05050200,
 	MFI_DCMD_CLUSTER =		0x08000000,
 	MFI_DCMD_CLUSTER_RESET_ALL =	0x08010100,
 	MFI_DCMD_CLUSTER_RESET_LD =	0x08010200
@@ -1173,6 +1176,15 @@ struct mfi_bbu_state {
 	uint8_t			reserved[21];
 } __packed;
 
+struct mfi_bbu_properties {
+	uint32_t		auto_learn_period;
+	uint32_t		next_learn_time;
+	uint8_t			learn_delay_interval;
+	uint8_t			auto_learn_mode;
+	uint8_t			bbu_mode;
+	uint8_t			reserved[21];
+} __packed;
+
 union mfi_bbu_status_detail {
 	struct mfi_ibbu_state	ibbu;
 	struct mfi_bbu_state	bbu;
diff --git a/usr.sbin/mfiutil/Makefile b/usr.sbin/mfiutil/Makefile
index dbf158d..c460b3f 100644
--- a/usr.sbin/mfiutil/Makefile
+++ b/usr.sbin/mfiutil/Makefile
@@ -1,12 +1,11 @@
 # $FreeBSD$
 PROG=	mfiutil
 
-SRCS=	mfiutil.c mfi_cmd.c mfi_config.c mfi_drive.c mfi_evt.c mfi_flash.c \
-	mfi_patrol.c mfi_show.c mfi_volume.c
+SRCS=	mfiutil.c mfi_bbu.c mfi_cmd.c mfi_config.c mfi_drive.c mfi_evt.c \
+	mfi_flash.c mfi_patrol.c mfi_show.c mfi_volume.c
 MAN8=	mfiutil.8
 
 CFLAGS+= -fno-builtin-strftime
-WARNS?=3
 
 DPADD=	${LIBUTIL}
 LDADD=	-lutil
diff --git a/usr.sbin/mfiutil/mfi_bbu.c b/usr.sbin/mfiutil/mfi_bbu.c
new file mode 100644
index 0000000..db16367
--- /dev/null
+++ b/usr.sbin/mfiutil/mfi_bbu.c
@@ -0,0 +1,249 @@
+/*-
+ * Copyright (c) 2013 Sandvine Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/param.h>
+#include <sys/errno.h>
+#include <sys/stat.h>
+#include <err.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include "mfiutil.h"
+
+/* The autolearn period is given in seconds. */
+void
+mfi_autolearn_period(uint32_t period, char *buf, size_t sz)
+{
+	unsigned int d, h;
+	char *tmp;
+
+	d = period / (24 * 3600);
+	h = (period % (24 * 3600)) / 3600;
+
+	tmp = buf;
+	if (d != 0) {
+		tmp += snprintf(buf, sz, "%u day%s", d, d == 1 ? "" : "s");
+		sz -= tmp - buf;
+		if (h != 0) {
+			tmp += snprintf(tmp, sz, ", ");
+			sz -= 2;
+		}
+	}
+	if (h != 0)
+		snprintf(tmp, sz, "%u hour%s", h, h == 1 ? "" : "s");
+
+	if (d == 0 && h == 0)
+		snprintf(tmp, sz, "less than 1 hour");
+}
+
+/* The time to the next relearn is given in seconds since 1/1/2000. */
+void
+mfi_next_learn_time(uint32_t next_learn_time, char *buf, size_t sz)
+{
+	time_t basetime;
+	struct tm tm;
+	size_t len;
+
+	memset(&tm, 0, sizeof(tm));
+	tm.tm_year = 100;
+	basetime = timegm(&tm);
+	basetime += (time_t)next_learn_time;
+	len = snprintf(buf, sz, "%s", ctime(&basetime));
+	if (len > 0)
+		/* Get rid of the newline added by ctime(3). */
+		buf[len - 1] = '\0';
+}
+
+void
+mfi_autolearn_mode(uint8_t mode, char *buf, size_t sz)
+{
+
+	switch (mode) {
+	case 0:
+		snprintf(buf, sz, "enabled");
+		break;
+	case 1:
+		snprintf(buf, sz, "disabled");
+		break;
+	case 2:
+		snprintf(buf, sz, "warn via event");
+		break;
+	default:
+		snprintf(buf, sz, "mode 0x%02x", mode);
+		break;
+	}
+}
+
+int
+mfi_bbu_get_props(int fd, struct mfi_bbu_properties *props, uint8_t *statusp)
+{
+
+	return (mfi_dcmd_command(fd, MFI_DCMD_BBU_GET_PROP, props,
+	    sizeof(*props), NULL, 0, statusp));
+}
+
+int
+mfi_bbu_set_props(int fd, struct mfi_bbu_properties *props, uint8_t *statusp)
+{
+
+	return (mfi_dcmd_command(fd, MFI_DCMD_BBU_SET_PROP, props,
+	    sizeof(*props), NULL, 0, statusp));
+}
+
+static int
+start_bbu_learn(int ac, char **av __unused)
+{
+	uint8_t status;
+	int error, fd;
+
+	status = MFI_STAT_OK;
+	error = 0;
+
+	if (ac != 1) {
+		warnx("start learn: unexpected arguments");
+		return (EINVAL);
+	}
+
+	fd = mfi_open(mfi_unit, O_RDWR);
+	if (fd < 0) {
+		error = errno;
+		warn("mfi_open");
+		return (error);
+	}
+
+	if (mfi_dcmd_command(fd, MFI_DCMD_BBU_START_LEARN, NULL, 0, NULL, 0,
+	    &status) < 0) {
+		error = errno;
+		warn("Failed to start BBU learn");
+	} else if (status != MFI_STAT_OK) {
+		warnx("Failed to start BBU learn: %s", mfi_status(status));
+		error = EIO;
+	}
+
+	return (error);
+}
+MFI_COMMAND(start, learn, start_bbu_learn);
+
+static int
+update_bbu_props(int ac, char **av)
+{
+	struct mfi_bbu_properties props;
+	unsigned long delay;
+	uint8_t status;
+	int error, fd;
+	char *mode, *endptr;
+
+	status = MFI_STAT_OK;
+	error = 0;
+
+	if (ac != 3) {
+		warnx("bbu: property and value required");
+		return (EINVAL);
+	}
+
+	fd = mfi_open(mfi_unit, O_RDWR);
+	if (fd < 0) {
+		error = errno;
+		warn("mfi_open");
+		return (error);
+	}
+
+	if (mfi_bbu_get_props(fd, &props, &status) < 0) {
+		error = errno;
+		warn("Failed to get BBU properties");
+		goto done;
+	} else if (status != MFI_STAT_OK) {
+		warnx("Failed to get BBU properties: %s", mfi_status(status));
+		error = EIO;
+		goto done;
+	}
+
+	if (strcmp(av[1], "learn-delay") == 0) {
+		delay = strtoul(av[2], &endptr, 10);
+		if (strlen(av[2]) == 0 || *endptr != '\0' || delay > 255) {
+			warnx("Invalid learn delay '%s'", av[2]);
+			error = EINVAL;
+			goto done;
+		}
+
+		props.learn_delay_interval = delay;
+	} else if (strcmp(av[1], "autolearn-mode") == 0) {
+		mode = av[2];
+
+		if (strcmp(av[2], "enable") == 0)
+			props.auto_learn_mode = 0;
+		else if (strcmp(av[2], "disable") == 0)
+			props.auto_learn_mode = 1;
+		else if (mode[0] >= '0' && mode[0] <= '2' && mode[1] == '\0')
+			props.auto_learn_mode = mode[0] - '0';
+		else {
+			warnx("Invalid mode '%s'", mode);
+			error = EINVAL;
+			goto done;
+		}
+	} else if (strcmp(av[1], "bbu-mode") == 0) {
+		if (props.bbu_mode == 0) {
+			warnx("This BBU does not implement different modes");
+			error = EINVAL;
+			goto done;
+		}
+
+		/* The mode must be an integer between 1 and 5. */
+		mode = av[2];
+		if (mode[0] < '1' || mode[0] > '5' || mode[1] != '\0') {
+			warnx("Invalid mode '%s'", mode);
+			error = EINVAL;
+			goto done;
+		}
+
+		props.bbu_mode = mode[0] - '0';
+	} else {
+		warnx("bbu: Invalid command '%s'", av[1]);
+		error = EINVAL;
+		goto done;
+	}
+
+	if (mfi_bbu_set_props(fd, &props, &status) < 0) {
+		error = errno;
+		warn("Failed to set BBU properties");
+		goto done;
+	} else if (status != MFI_STAT_OK) {
+		warnx("Failed to set BBU properties: %s", mfi_status(status));
+		error = EIO;
+		goto done;
+	}
+
+done:
+	close(fd);
+
+	return (error);
+}
+MFI_COMMAND(top, bbu, update_bbu_props);
diff --git a/usr.sbin/mfiutil/mfi_cmd.c b/usr.sbin/mfiutil/mfi_cmd.c
index 7fedfb6..3cf703a 100644
--- a/usr.sbin/mfiutil/mfi_cmd.c
+++ b/usr.sbin/mfiutil/mfi_cmd.c
@@ -301,12 +301,12 @@ mfi_ctrl_get_info(int fd, struct mfi_ctrl_info *info, uint8_t *statusp)
 }
 
 int
-mfi_open(int unit)
+mfi_open(int unit, int acs)
 {
 	char path[MAXPATHLEN];
 
 	snprintf(path, sizeof(path), "/dev/mfi%d", unit);
-	return (open(path, O_RDWR));
+	return (open(path, acs));
 }
 
 void
diff --git a/usr.sbin/mfiutil/mfi_config.c b/usr.sbin/mfiutil/mfi_config.c
index 32cb171..8576bc3 100644
--- a/usr.sbin/mfiutil/mfi_config.c
+++ b/usr.sbin/mfiutil/mfi_config.c
@@ -35,6 +35,7 @@
 #endif
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <libutil.h>
 #ifdef DEBUG
 #include <stdint.h>
@@ -151,13 +152,13 @@ mfi_config_lookup_volume(struct mfi_config_data *config, uint8_t target_id)
 }
 
 static int
-clear_config(int ac, char **av)
+clear_config(int ac __unused, char **av __unused)
 {
 	struct mfi_ld_list list;
 	int ch, error, fd;
 	u_int i;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -211,9 +212,8 @@ clear_config(int ac, char **av)
 }
 MFI_COMMAND(top, clear, clear_config);
 
-#define	MFI_ARRAY_SIZE		288
-#define	MAX_DRIVES_PER_ARRAY						\
-	((MFI_ARRAY_SIZE - sizeof(struct mfi_array)) / 8)
+#define MAX_DRIVES_PER_ARRAY MFI_MAX_ROW_SIZE
+#define MFI_ARRAY_SIZE sizeof(struct mfi_array)
 
 #define	RT_RAID0	0
 #define	RT_RAID1	1
@@ -305,7 +305,7 @@ parse_array(int fd, int raid_type, char *array_str, struct array_info *info)
 
 	/* Validate the number of drives for this array. */
 	if (count >= MAX_DRIVES_PER_ARRAY) {
-		warnx("Too many drives for a single array: max is %zu",
+		warnx("Too many drives for a single array: max is %d",
 		    MAX_DRIVES_PER_ARRAY);
 		return (EINVAL);
 	}
@@ -411,7 +411,7 @@ find_next_volume(struct config_id_state *state)
 
 /* Populate an array with drives. */
 static void
-build_array(int fd, char *arrayp, struct array_info *array_info,
+build_array(int fd __unused, char *arrayp, struct array_info *array_info,
     struct config_id_state *state, int verbose)
 {
 	struct mfi_array *ar = (struct mfi_array *)arrayp;
@@ -576,7 +576,7 @@ create_volume(int ac, char **av)
 	narrays = 0;
 	error = 0;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -858,7 +858,7 @@ delete_volume(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -926,7 +926,7 @@ add_spare(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -1051,7 +1051,7 @@ remove_spare(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -1197,7 +1197,7 @@ debug_config(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -1234,7 +1234,7 @@ dump(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_drive.c b/usr.sbin/mfiutil/mfi_drive.c
index 6341fd8..2bc902e 100644
--- a/usr.sbin/mfiutil/mfi_drive.c
+++ b/usr.sbin/mfiutil/mfi_drive.c
@@ -33,6 +33,7 @@
 #include <sys/errno.h>
 #include <ctype.h>
 #include <err.h>
+#include <fcntl.h>
 #include <libutil.h>
 #include <limits.h>
 #include <stdio.h>
@@ -71,7 +72,7 @@ mfi_drive_name(struct mfi_pd_info *pinfo, uint16_t device_id, uint32_t def)
 		else
 			snprintf(buf, sizeof(buf), "%2u", device_id);
 
-		fd = mfi_open(mfi_unit);
+		fd = mfi_open(mfi_unit, O_RDWR);
 		if (fd < 0) {
 			warn("mfi_open");
 			return (buf);
@@ -149,7 +150,7 @@ mfi_pdstate(enum mfi_pd_state state)
 	case MFI_PD_STATE_COPYBACK:
 		return ("COPYBACK");
 	case MFI_PD_STATE_SYSTEM:
-		return ("SYSTEM");
+		return ("JBOD");
 	default:
 		sprintf(buf, "PSTATE 0x%04x", state);
 		return (buf);
@@ -329,11 +330,13 @@ cam_strvis(char *dst, const char *src, int srclen, int dstlen)
 const char *
 mfi_pd_inq_string(struct mfi_pd_info *info)
 {
-	struct scsi_inquiry_data *inq_data;
+	struct scsi_inquiry_data iqd, *inq_data = &iqd;
 	char vendor[16], product[48], revision[16], rstr[12], serial[SID_VENDOR_SPECIFIC_0_SIZE];
 	static char inq_string[64];
 
-	inq_data = (struct scsi_inquiry_data *)info->inquiry_data;
+	memcpy(inq_data, info->inquiry_data,
+	    (sizeof (iqd) <  sizeof (info->inquiry_data))?
+	    sizeof (iqd) : sizeof (info->inquiry_data));
 	if (SID_QUAL_IS_VENDOR_UNIQUE(inq_data))
 		return (NULL);
 	if (SID_TYPE(inq_data) != T_DIRECT)
@@ -383,7 +386,7 @@ drive_set_state(char *drive, uint16_t new_state)
 	uint8_t mbox[6];
 	int error, fd;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -471,6 +474,20 @@ rebuild_drive(int ac, char **av)
 MFI_COMMAND(top, rebuild, rebuild_drive);
 
 static int
+syspd_drive(int ac, char **av)
+{
+
+	if (ac != 2) {
+		warnx("syspd: %s", ac > 2 ? "extra arguments" :
+		    "drive required");
+		return (EINVAL);
+	}
+
+	return (drive_set_state(av[1], MFI_PD_STATE_SYSTEM));
+}
+MFI_COMMAND(top, syspd, syspd_drive);
+
+static int
 start_rebuild(int ac, char **av)
 {
 	struct mfi_pd_info info;
@@ -484,7 +501,7 @@ start_rebuild(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -541,7 +558,7 @@ abort_rebuild(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -597,7 +614,7 @@ drive_progress(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -663,7 +680,7 @@ drive_clear(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -723,7 +740,7 @@ drive_locate(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_evt.c b/usr.sbin/mfiutil/mfi_evt.c
index dbf8272..c9a1a6d 100644
--- a/usr.sbin/mfiutil/mfi_evt.c
+++ b/usr.sbin/mfiutil/mfi_evt.c
@@ -32,6 +32,7 @@
 #include <sys/types.h>
 #include <sys/errno.h>
 #include <err.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
@@ -63,7 +64,7 @@ mfi_get_events(int fd, struct mfi_evt_list *list, int num_events,
 }
 
 static int
-show_logstate(int ac, char **av)
+show_logstate(int ac, char **av __unused)
 {
 	struct mfi_evt_log_state info;
 	int error, fd;
@@ -73,7 +74,7 @@ show_logstate(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -541,7 +542,7 @@ show_events(int ac, char **av)
 	int ch, error, fd, num_events, verbose;
 	u_int i;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_flash.c b/usr.sbin/mfiutil/mfi_flash.c
index 6d07cb0..2601025 100644
--- a/usr.sbin/mfiutil/mfi_flash.c
+++ b/usr.sbin/mfiutil/mfi_flash.c
@@ -150,7 +150,7 @@ flash_adapter(int ac, char **av)
 		goto error;
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_patrol.c b/usr.sbin/mfiutil/mfi_patrol.c
index 1d66aea..98e2340 100644
--- a/usr.sbin/mfiutil/mfi_patrol.c
+++ b/usr.sbin/mfiutil/mfi_patrol.c
@@ -32,6 +32,7 @@
 #include <sys/types.h>
 #include <sys/errno.h>
 #include <err.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -74,7 +75,7 @@ patrol_get_props(int fd, struct mfi_pr_properties *prop)
 }
 
 static int
-show_patrol(int ac, char **av)
+show_patrol(int ac __unused, char **av __unused)
 {
 	struct mfi_pr_properties prop;
 	struct mfi_pr_status status;
@@ -86,7 +87,7 @@ show_patrol(int ac, char **av)
 	int error, fd;
 	u_int i;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -192,11 +193,11 @@ show_patrol(int ac, char **av)
 MFI_COMMAND(show, patrol, show_patrol);
 
 static int
-start_patrol(int ac, char **av)
+start_patrol(int ac __unused, char **av __unused)
 {
 	int error, fd;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -218,11 +219,11 @@ start_patrol(int ac, char **av)
 MFI_COMMAND(start, patrol, start_patrol);
 
 static int
-stop_patrol(int ac, char **av)
+stop_patrol(int ac __unused, char **av __unused)
 {
 	int error, fd;
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -293,7 +294,7 @@ patrol_config(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_show.c b/usr.sbin/mfiutil/mfi_show.c
index 4f83b52..dd55958 100644
--- a/usr.sbin/mfiutil/mfi_show.c
+++ b/usr.sbin/mfiutil/mfi_show.c
@@ -32,6 +32,7 @@
 #include <sys/types.h>
 #include <sys/errno.h>
 #include <err.h>
+#include <fcntl.h>
 #include <libutil.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -50,7 +51,7 @@ format_stripe(char *buf, size_t buflen, uint8_t stripe)
 }
 
 static int
-show_adapter(int ac, char **av)
+show_adapter(int ac, char **av __unused)
 {
 	struct mfi_ctrl_info info;
 	char stripe[5];
@@ -61,7 +62,7 @@ show_adapter(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -135,20 +136,22 @@ show_adapter(int ac, char **av)
 MFI_COMMAND(show, adapter, show_adapter);
 
 static int
-show_battery(int ac, char **av)
+show_battery(int ac, char **av __unused)
 {
 	struct mfi_bbu_capacity_info cap;
 	struct mfi_bbu_design_info design;
+	struct mfi_bbu_properties props;
 	struct mfi_bbu_status stat;
 	uint8_t status;
-	int comma, error, fd, show_capacity;
+	int comma, error, fd, show_capacity, show_props;
+	char buf[32];
 
 	if (ac != 1) {
 		warnx("show battery: extra arguments");
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -185,6 +188,14 @@ show_battery(int ac, char **av)
 		return (error);
 	}
 
+	if (mfi_bbu_get_props(fd, &props, &status) < 0) {
+		error = errno;
+		warn("Failed to get properties");
+		close(fd);
+		return (error);
+	}
+	show_props = (status == MFI_STAT_OK);
+
 	printf("mfi%d: Battery State:\n", mfi_unit);
 	printf("     Manufacture Date: %d/%d/%d\n", design.mfg_date >> 5 & 0x0f,
 	    design.mfg_date & 0x1f, design.mfg_date >> 9 & 0xffff);
@@ -204,6 +215,23 @@ show_battery(int ac, char **av)
 	printf("       Design Voltage: %d mV\n", design.design_voltage);
 	printf("      Current Voltage: %d mV\n", stat.voltage);
 	printf("          Temperature: %d C\n", stat.temperature);
+	if (show_props) {
+		mfi_autolearn_period(props.auto_learn_period, buf, sizeof(buf));
+		printf("     Autolearn period: %s\n", buf);
+		if (props.auto_learn_mode != 0)
+			snprintf(buf, sizeof(buf), "never");
+		else
+			mfi_next_learn_time(props.next_learn_time, buf,
+			    sizeof(buf));
+		printf("      Next learn time: %s\n", buf);
+		printf(" Learn delay interval: %u hour%s\n",
+		    props.learn_delay_interval,
+		    props.learn_delay_interval != 1 ? "s" : "");
+		mfi_autolearn_mode(props.auto_learn_mode, buf, sizeof(buf));
+		printf("       Autolearn mode: %s\n", buf);
+		if (props.bbu_mode != 0)
+			printf("             BBU Mode: %d\n", props.bbu_mode);
+	}
 	printf("               Status:");
 	comma = 0;
 	if (stat.fw_status & MFI_BBU_STATE_PACK_MISSING) {
@@ -224,7 +252,29 @@ show_battery(int ac, char **av)
 	}
 	if (stat.fw_status & MFI_BBU_STATE_DISCHARGE_ACTIVE) {
 		printf("%s DISCHARGING", comma ? "," : "");
+		comma = 1;
+	}
+	if (stat.fw_status & MFI_BBU_STATE_LEARN_CYC_REQ) {
+		printf("%s LEARN_CYCLE_REQUESTED", comma ? "," : "");
+		comma = 1;
 	}
+	if (stat.fw_status & MFI_BBU_STATE_LEARN_CYC_ACTIVE) {
+		printf("%s LEARN_CYCLE_ACTIVE", comma ? "," : "");
+		comma = 1;
+	}
+	if (stat.fw_status & MFI_BBU_STATE_LEARN_CYC_FAIL) {
+		printf("%s LEARN_CYCLE_FAIL", comma ? "," : "");
+		comma = 1;
+	}
+	if (stat.fw_status & MFI_BBU_STATE_LEARN_CYC_TIMEOUT) {
+		printf("%s LEARN_CYCLE_TIMEOUT", comma ? "," : "");
+		comma = 1;
+	}
+	if (stat.fw_status & MFI_BBU_STATE_I2C_ERR_DETECT) {
+		printf("%s I2C_ERROR_DETECT", comma ? "," : "");
+		comma = 1;
+	}
+
 	if (!comma)
 		printf(" normal");
 	printf("\n");
@@ -281,7 +331,7 @@ print_pd(struct mfi_pd_info *info, int state_len)
 }
 
 static int
-show_config(int ac, char **av)
+show_config(int ac, char **av __unused)
 {
 	struct mfi_config_data *config;
 	struct mfi_array *ar;
@@ -298,7 +348,7 @@ show_config(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -387,7 +437,7 @@ show_config(int ac, char **av)
 MFI_COMMAND(show, config, show_config);
 
 static int
-show_volumes(int ac, char **av)
+show_volumes(int ac, char **av __unused)
 {
 	struct mfi_ld_list list;
 	struct mfi_ld_info info;
@@ -399,7 +449,7 @@ show_volumes(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -470,7 +520,7 @@ show_volumes(int ac, char **av)
 MFI_COMMAND(show, volumes, show_volumes);
 
 static int
-show_drives(int ac, char **av)
+show_drives(int ac, char **av __unused)
 {
 	struct mfi_pd_list *list;
 	struct mfi_pd_info info;
@@ -482,7 +532,7 @@ show_drives(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -578,7 +628,7 @@ display_firmware(struct mfi_info_component *comp, const char *tag)
 }
 
 static int
-show_firmware(int ac, char **av)
+show_firmware(int ac, char **av __unused)
 {
 	struct mfi_ctrl_info info;
 	struct mfi_info_component header;
@@ -590,7 +640,7 @@ show_firmware(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -634,7 +684,7 @@ show_firmware(int ac, char **av)
 MFI_COMMAND(show, firmware, show_firmware);
 
 static int
-show_progress(int ac, char **av)
+show_progress(int ac, char **av __unused)
 {
 	struct mfi_ld_list llist;
 	struct mfi_pd_list *plist;
@@ -650,7 +700,7 @@ show_progress(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfi_volume.c b/usr.sbin/mfiutil/mfi_volume.c
index 836f045..2306256 100644
--- a/usr.sbin/mfiutil/mfi_volume.c
+++ b/usr.sbin/mfiutil/mfi_volume.c
@@ -32,6 +32,7 @@
 #include <sys/types.h>
 #include <sys/errno.h>
 #include <err.h>
+#include <fcntl.h>
 #include <libutil.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -294,7 +295,7 @@ volume_cache(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -362,7 +363,8 @@ volume_cache(int ac, char **av)
 			break;
 		}
 		if (props.default_cache_policy != props.current_cache_policy)
-			printf("Cache Disabled Due to Dead Battery\n");
+			printf(
+	"Cache disabled due to dead battery or ongoing battery relearn\n");
 		error = 0;
 	} else {
 		new = props;
@@ -402,7 +404,7 @@ volume_name(int ac, char **av)
 		return (ENOSPC);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDWR);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
@@ -453,7 +455,7 @@ volume_progress(int ac, char **av)
 		return (EINVAL);
 	}
 
-	fd = mfi_open(mfi_unit);
+	fd = mfi_open(mfi_unit, O_RDONLY);
 	if (fd < 0) {
 		error = errno;
 		warn("mfi_open");
diff --git a/usr.sbin/mfiutil/mfiutil.8 b/usr.sbin/mfiutil/mfiutil.8
index b948b95..e193918 100644
--- a/usr.sbin/mfiutil/mfiutil.8
+++ b/usr.sbin/mfiutil/mfiutil.8
@@ -88,6 +88,9 @@
 .Cm rebuild Ar drive
 .Nm
 .Op Fl u Ar unit
+.Cm syspd Ar drive
+.Nm
+.Op Fl u Ar unit
 .Cm drive progress Ar drive
 .Nm
 .Op Fl u Ar unit
@@ -141,6 +144,12 @@
 .Nm
 .Op Fl u Ar unit
 .Cm flash Ar file
+.Nm
+.Op Fl u Ar unit
+.Cm start learn
+.Nm
+.Op Fl u Ar unit
+.Cm bbu Ar setting Ar value
 .Sh DESCRIPTION
 The
 .Nm
@@ -346,6 +355,11 @@ Mark a failed
 that is still part of an array as a good drive suitable for a rebuild.
 The firmware should kick off an array rebuild on its own if a failed drive
 is marked as a rebuild drive.
+.It Cm syspd Ar drive
+Present the drive to the host operating system as a disk SYSPD block device in
+the format /dev/mfisyspdX.  Clear this flag with
+.Cm good
+.Ar drive
 .It Cm drive progress Ar drive
 Report the current progress and estimated completion time of drive operations
 such as rebuilds or patrol reads.
@@ -565,6 +579,37 @@ Stop a currently running patrol read operation.
 Updates the flash on the controller with the firmware stored in
 .Ar file .
 A reboot is required for the new firmware to take effect.
+.It Cm start learn
+Start a battery relearn.
+Note that this seems to always result in the battery being completely drained,
+regardless of the BBU mode.
+In particular, the controller write cache will be disabled during the relearn
+even if transparent learning mode is enabled.
+.It Cm bbu Ar setting Ar value
+Update battery backup unit (BBU) properties related to battery relearning.
+The following settings are configurable:
+.Bl -tag -width indent
+.It Cm learn-delay
+Add a delay to the next scheduled battery relearn event. This setting is
+given in hours and must lie in the range of 0 to 255.
+.It Cm autolearn-mode
+Enable or disable automatic periodic battery relearning.
+The setting may be set to
+.Dq enable
+or
+.Dq disable
+to respectively enable or disable the relearn cycle.
+Alternatively, a mode of 0, 1 or 2 may be given.
+Mode 0 enables periodic relearning, mode 1 disables it, and mode 2 disables
+it and logs a warning to the event log when it detects that a battery relearn
+should be performed.
+.It Cm bbu-mode
+Set the BBU's mode of operation. This setting is not supported by all BBUs.
+Where it is supported, the possible values are the integers between 1 and 5
+inclusive.
+Modes 1, 2 and 3 enable a transparent learn cycle, whereas modes 4 and 5 do not.
+The BBU's data retention time is greater when transparent learning is not used.
+.El
 .El
 .Sh EXAMPLES
 Configure the cache for volume mfid0 to cache only writes:
@@ -593,6 +638,10 @@ Add the drive in slot 2 in the main chassis as a hot spare for volume mfid0:
 .Pp
 .Dl Nm Cm add s2 mfid0
 .Pp
+Reconfigure a disk as a SYSPD block device with no RAID
+.Pp
+.Dl Nm Cm syspd 0
+.Pp
 Configure the adapter to run periodic patrol reads once a week with the first
 patrol read starting in 5 minutes:
 .Pp
diff --git a/usr.sbin/mfiutil/mfiutil.c b/usr.sbin/mfiutil/mfiutil.c
index 43bb6bb..8b00029 100644
--- a/usr.sbin/mfiutil/mfiutil.c
+++ b/usr.sbin/mfiutil/mfiutil.c
@@ -65,8 +65,9 @@ usage(void)
 	fprintf(stderr, "    show patrol               - display patrol read status\n");
 	fprintf(stderr, "    show progress             - display status of active operations\n");
 	fprintf(stderr, "    fail <drive>              - fail a physical drive\n");
-	fprintf(stderr, "    good <drive>              - mark a bad physical drive as good\n");
+	fprintf(stderr, "    good <drive>              - set a failed/SYSPD drive as UNCONFIGURED\n");
 	fprintf(stderr, "    rebuild <drive>           - mark failed drive ready for rebuild\n");
+	fprintf(stderr, "    syspd <drive>             - set drive into use as SYSPD JBOD\n");
 	fprintf(stderr, "    drive progress <drive>    - display status of active operations\n");
 	fprintf(stderr, "    drive clear <drive> <start|stop> - clear a drive with all 0x00\n");
 	fprintf(stderr, "    start rebuild <drive>\n");
@@ -84,6 +85,8 @@ usage(void)
 	fprintf(stderr, "    start patrol              - start a patrol read\n");
 	fprintf(stderr, "    stop patrol               - stop a patrol read\n");
 	fprintf(stderr, "    flash <firmware>\n");
+	fprintf(stderr, "    start learn               - start a BBU relearn\n");
+	fprintf(stderr, "    bbu <setting> <value>     - set BBU properties\n");
 #ifdef DEBUG
 	fprintf(stderr, "    debug                     - debug 'show config'\n");
 	fprintf(stderr, "    dump                      - display 'saved' config\n");
@@ -92,10 +95,10 @@ usage(void)
 }
 
 static int
-version(int ac, char **av)
+version(int ac __unused, char **av __unused)
 {
 
-	printf("mfiutil version 1.0.13");
+	printf("mfiutil version 1.0.15");
 #ifdef DEBUG
 	printf(" (DEBUG)");
 #endif
diff --git a/usr.sbin/mfiutil/mfiutil.h b/usr.sbin/mfiutil/mfiutil.h
index 232831e..33eddb5 100644
--- a/usr.sbin/mfiutil/mfiutil.h
+++ b/usr.sbin/mfiutil/mfiutil.h
@@ -139,7 +139,7 @@ int	mfi_lookup_drive(int fd, char *drive, uint16_t *device_id);
 int	mfi_lookup_volume(int fd, const char *name, uint8_t *target_id);
 int	mfi_dcmd_command(int fd, uint32_t opcode, void *buf, size_t bufsize,
     uint8_t *mbox, size_t mboxlen, uint8_t *statusp);
-int	mfi_open(int unit);
+int	mfi_open(int unit, int acs);
 int	mfi_ctrl_get_info(int fd, struct mfi_ctrl_info *info, uint8_t *statusp);
 int	mfi_ld_get_info(int fd, uint8_t target_id, struct mfi_ld_info *info,
     uint8_t *statusp);
@@ -151,5 +151,12 @@ int	mfi_reconfig_supported(void);
 const char *mfi_status(u_int status_code);
 const char *mfi_drive_name(struct mfi_pd_info *pinfo, uint16_t device_id,
     uint32_t def);
+int	mfi_bbu_get_props(int fd, struct mfi_bbu_properties *props,
+	    uint8_t *statusp);
+int	mfi_bbu_set_props(int fd, struct mfi_bbu_properties *props,
+	    uint8_t *statusp);
+void	mfi_autolearn_period(uint32_t, char *, size_t);
+void	mfi_next_learn_time(uint32_t, char *, size_t);
+void	mfi_autolearn_mode(uint8_t, char *, size_t);
 
 #endif /* !__MFIUTIL_H__ */
